# 动态规划

## 背包问题

### Acwing.2 01背包问题

> 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
>
> 第 i 件物品的体积是 vi，价值是 wi。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
>
> 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

二维，复杂度为O(n^2)

```c++
#include<iostream>
using namespace std;

int n, m;
int v[1010],w[1010];
int f[1010][1010];	//f[i][j]表示只考虑前i个物品时，j体积以内的最大价值

int main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i ++)
        cin>>v[i]>>w[i];
    for(int i = 1; i <=n; i ++){
        for(int j = 0; j <= m; j ++){
            if(j < v[i])	//说明j体积以内选不了第i个物品
                f[i][j] = f[i - 1][j];
            else
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);	//选第i个物品带来的价值变化决定是否选它
        }
    }
    cout<<f[n][m]<<endl;
    return 0;
}
```

一维

```c++
#include<iostream>
using namespace std;

int n, m;
int v[1010],w[1010];
int f[1010];	//f[j]最终表示考虑所有物品时，j体积以内的最大价值

int main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i ++)
        cin>>v[i]>>w[i];
    for(int i = 1; i <= n; i ++)	//此循环中，f[j]表示考虑前i个物品时，j体积以内的最大价值
        for(int j = m; j >= v[i]; j --)	//此逆序循环是为了使用“考虑i-1个物品时f[j]的值”，对应二维状态下f[i-1][j]
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout<<f[m]<<endl;
    return 0;
}
```

[参考题解](https://www.acwing.com/solution/content/1374/)

### 

### Acwing.3 完全背包问题

与01背包问题的唯一区别在于每个物品可以用无限次

朴素版（会超时）

```c++
#include<iostream>
using namespace std;

int n, m;
int v[1010],w[1010];
int f[1010];	//f[j]最终表示考虑所有物品时，j体积以内的最大价值

int main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i ++)
        cin>>v[i]>>w[i];
    for(int i = 1; i <= n; i ++)	//此循环中，f[j]表示考虑前i个物品时，j体积以内的最大价值
        for(int j = m; j >= v[i]; j --)	//此逆序循环是为了使用“考虑i-1个物品时f[j]的值”，对应二维状态下f[i-1][j]
            for(int k = 0; j >= k * v[i]; k ++)	// 在01背包一维情况下新增一层循环，满足每种物品有无限个的条件。
            f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
    cout<<f[m]<<endl;
    return 0;
}
```

我们知道第二层循环逆序以“只考虑i-1个物品”，然而由于每个物品有无限个，恰好不需要顾虑一维的f[j]已经被更新的问题。将第二层循环改成正序即是答案。

证明参考[Tell_me题解](https://www.acwing.com/solution/content/5345/)

> ```
> f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
> f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-2*v]+2*w , .....)
> 由上两式，可得出如下递推关系： 
>                         f[i][j]=max(f[i,j-v]+w , f[i-1][j]) 
> //01背包问题的递推关系     f[i][j]=max(f[i-1,j-v]+w , f[i-1][j]) 
> ```

```c++
#include<iostream>
using namespace std;

int n, m;
int v[1010],w[1010];
int f[1010];	//f[j]最终表示考虑所有物品时，j体积以内的最大价值

int main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i ++)
        cin>>v[i]>>w[i];
    for(int i = 1; i <= n; i ++)	//此循环中，f[j]表示考虑前i个物品时，j体积以内的最大价值
        for(int j = v[i]; j <= m; j ++)	//
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout<<f[m]<<endl;
    return 0;
}
```



### Acwing.4 多重背包问题 I

与01背包的区别在于每件物品有特定件数，同时物品数量、物品价值范围从1000降到100，意味着可以用三重循环，那么用完全背包问题的朴素解即可。

```c++
#include<iostream>
using namespace std;

const int N = 101;
int n, m;
int v[N], w[N], s[N];
int f[N];
int main(){
    cin >> n >> m;
    for(int i = 0; i < n; i ++)
        cin >> v[i] >> w[i] >> s[i];
    
    for(int i = 0; i < n; i ++){
        for(int j = m; j >= v[i]; j --){
            for(int k = 0; k <= s[i] && j >= k * v[i]; k ++){
                f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout<<f[m]<<endl;
    return 0;
}
```



### Acwing.5 多重背包问题 II

与上一题的区别在于数据范围达到1000，三重循环会超时。可以使用将多重背包拆成01背包的问题，即将“选几个”变成“选与不选”。例如一个物品有9个，可以拆成9个物品，但这样无法降低复杂度。通过二进制拆包，将9个物品拆成4个，分别相当于之前物品x1、x2、x4、x2，然后对这四个物品进行01背包的计算。

```c++
#include<iostream>
#include<vector>
using namespace std;

int n, m;
const int N = 2010;
int f[N];
struct Good{
    int v, w;        
};
vector<Good> goods;

int main(){
    cin >> n >> m;
    for(int i = 0; i < n; i ++){
        int v, w, s;
        cin >> v >> w >> s;
      	//二进制拆分，新物品的重量与价值都是之前的k倍
        for(int k = 1; k <= s; k *= 2){
            s -= k;
            goods.push_back({v * k, w * k});
        }
      	//拆到最后，剩余的作为一个物品
        if(s > 0)   goods.push_back({v * s, w * s});
    }
    //01背包
    for(auto good : goods){
        for(int j = m; j >= good.v; j --){
            f[j] = max(f[j], f[j - good.v] + good.w);
        }
    }
    cout<<f[m]<<endl;
    return 0;
}
```

